1、react函数组件使用useState就是增加了函数组件从内部更新UI的方法
2、cookie属性：name、value、domain、path、Expires/Max-age、Size、HttpOnly(不能用DOM操作cookie)、Secure(HTTPS)
3、函数组件刷新，子组件情况？
4、react useState更新数据是异步的
5、react父组件render后不管向子组件传递的props是否变化，都会再传进去一个props对象，可在子组件中使用
      shouldComponentUpdate判断props是否有变化决定子组件是否render
6、父组件中向子组件传递props是赋值，并不是绑定，即子组件不会捕捉到父组件传递props的那个变量的变化，所以父组件的
      变量作为props传递给子组件时子组件并不会重新render。把state作为子组件props会导致子组件render的原因是父组件重新
       render，子组件又被传递了一次props，即使props没有变化也会执行componentWillReceiveProps钩子
7、GUI线程渲染页面过程：解析DOM树和CSSOM树，把DOM和CSS树合并成renderTree，reflow/layout（重排）计算几何信息，
       repaint（重绘）绘制页面。
8、DOM的几何属性改变会导致重排，然后重绘，非几何属性改变会导致重绘，渲染的四个过程可看作是钩子函数
9、new运算符：创建空对象并把this引用该对象，把_proto_指向构造函数的原型(prototype)，执行func.call(对象)
10、HTML5：语义标签、浏览器存储(localStorage、sessionStorage)、data自定义属性
11、HTML５data-用法：标签中定义data-article-name，获取该标签的DOM结点，通过dataset属性获取自定义data值，
        获取后的变量名是驼峰形式的
12、css @import必须放在其他样式之前使用，否则不会导入
13、BFC区域不会与浮动元素重叠，即不会覆盖浮动元素
14、vue项目启动加载过程
15、vue生命周期中的各个对象及做的事？
16、vue组件this的各个属性？$el有什么？vue2和vue3生命周期区别
17、对比react生命周期
18、vue组件的$el是在beforeMount之后创建的，即挂载时创建的
19、vue2双向绑定原理？弊端？
20、$nexttick原理？
21、JavaScript常用设计模式？
22、JavaScript全局异常检测？
23、路由守卫？
24、vue props和react类似，可组件内定义，可从父组件接收，不能修改。父组件传过来对象时，是浅拷贝
25、react构造函数能否访问普通变量？可以访问
26、vue钩子函数什么阶段可以访问什么内容？ 
27、setup定义watch、computed属性
28、vue：watch、computed、filter
29、vue3 setup的props参数不能使用es6解构是因为props是响应式的，即父组件传来的props变化后子组件收到的props也会变，
        解构出来的话解构的变量值不会随着props改变而改变，所以需要用toRefs解构 
30、vue3：computed、watch使用
31、vue3的computed和在使用本质上没有变化，形式上做了改变。本质上computed多了定义可读写变量
32、vue3 setup定义响应式对象:通过ref函数赋值，使用变量名.value访问修改变量。基本类型和对象的响应式实现不一样，
       基本类型通过refImpl实现，对象通过proxy实现
33、vue3 setup作用：定义vue2中的data、methods、computed、watch等属性，作为钩子函数。注意：setup是在create之前
        执行的，所以UI刷新后不会执行setup！！！
34、在setup中通过ref设置的响应式变量，基本类型通过.value访问值，对象通过.value也是访问到值，属性不需要再通过value
        访问，可直接访问，因为基本类型和对象的响应式实现不同。数组也是对象类型，所以也是通过.value访问值，再通过[]
        访问元素 
35、reactive创建响应式对象，不需要写value，语义化更好
36、es6 proxy给对象添加访问属性的拦截器，可设置所有属性，而object.defineProperty是给对象的一个属性添加拦截器等属性。
        proxy是设置对象原本就有的属性，且生成了一个代理对象，而object.defineProperty是给对象添加一个新属性。vue的$set
       可能就是封装了object.defineProperty
37、vue2更改数组值？使用数组方法（vue封装过了）或使用vue.set或this.$set
38、观察者模式启发：在观察者对象的构造函数中把该对象添加进观察者集合中，添加方法的参数是实例对象，传参时可以传入
        this，因为对象中this指的是当前对象的引用
39、观察者模式参考：https://blog.csdn.net/yexudengzhidao/article/details/90183416
40、数组push对象，添加进去的是地址，相当于浅拷贝
41、vue2双向绑定原理：通过观察者模式实现
42、 Object.prototype.toString.call()原理：把object原型的toString方法绑定到(call的作用)括号内的对象上，返回的就是
        对应的数据类型，基本类型返回的是对应的对象类型，因为是函数调用，会临时创建一个对象，所以是对象类型，无法判断
        是否是基本类型。不加call函数，返回的都是Object，可能是this在prototype上的原因
43、es6proxy的set函数不能修改value，即只能接收设置的值并作出一些相应，而不能修改设置的值！！！object.defineProperty
        的set应该也是。（但是可以设置原对象的值，通过target参数）
44、vue2响应式缺点：对象直接添加删除属性不会更新UI，数组通过下标修改元素也不会更新UI。解决办法：给对象添加属性
        通过this.$set或vue.set，删除属性通过this.$delete或vue.delete。修改数组元素通过set或$set或者通过数组方法，数组
        方法是vue封装过的
45、分清楚vue响应式原理和双向绑定原理
46、vue2响应式：初始化时把data的属性全部转为getter和setter，是把同名属性作为vue实例的属性，弄清楚了已经定义的属性
        怎么通过object.defineProperty 处理
47、vue2响应式实现：实例化vue对象后，遍历data对象，通过Object.defineProperty把属性添加到实例上面，如果data的属性
       是对象，则先给实例加一个同名空对象，再使用Object.defineProperty定义属性，再进行赋值操作，当数据变化时，触发
        setter，修改data的数据，接着使用该数据的节点监听到数据变化，更新UI（这一步是在data对象中添加setter来通知节点
        更新，叫做数据劫持，不是在实例上的代理的setter中添加的监听），主题对象在属性的setter中，节点的更新函数添加到
         了主题对象的订阅者集合中
48、vue3响应式实现：通过Proxy代理对象，而不是vue2的给实例添加同名对象再给对象添加代理属性，通过reflect修改原对象
        属性并进行更新UI操作。代理基本类型方法待定
49、Object.defineProperty设置属性如果不加value，只设置setter和getter，该属性不算是对象的正常属性，只作为代理作用，
        不能正常赋值，vue2响应式原理即将data的数据代理到组件实例上面，修改时修改的是data，并不是对象上的代理属性，
         代理属性不能赋值
50、es6 Proxy第二个参数如果是空对象，则代理对象的get默认返回原对象对应属性，修改代理对象的属性也修改原对象
        的对应属性，添加删除属性也一样
51、vue3响应式原理优势：因为Proxy代理的是一个对象，或者说监听的是一个对象，所以能检测所有属性，新加属性时，
        可以直接捕获到并触发setter，进行更新UI操作
52、‘2’ + 2 = ‘22’。加法是转为字符合并，减法是转为算术运算，不能运算就是NAN
53、JavaScript数组sort方法参数从小到大排序：function(a, b){return a - b},从大到小：return b - a。元素是对象也可以
54、双指针问题：根据固定的数找指针位置，不要根据两个指针位置找另一个数
55、JavaScript数组：find和findIndex是传入函数，返回符合得元素的索引。indexOf是传入元素，返回元素索引
56、Map初始化是传入一个数组，键值对也用数组包裹
57、JavaScript ！：!0是true，!2(非0数字)是false，![]是false，![].length是true。1和0可以替代true、false，一般不用
58、Object.getprototypeOf()获取对象的原型。Object的原型是null
59、NAN是number类型，typeof NAN是number。isNAN()将参数转为number判断（非NAN的数字），number.isNAN()先
        判断是否是number类型再转为number(非NAN的数字)，number.isNAN更准确
60、new Array(2)，初始化长度为2的空数组（length属性为2，实际上是空数组）
61、undefined是不知道是什么类型，可能是基本类型也可能是引用类型，null是指明了是指向引用的数据类型，但是现在没有指向，
        undefi的变量作为全局对象的属性，null不作为全局对象的属性
62、观察者模式存储观察者的集合是直接存储观察者，发布订阅模式存储的是根据type分类的观察者数组
63、async await中await后如果是同步语句就执行，如果是异步任务就正常异步任务，异步任务不会被等待执行，还是在处理异步
        任务的线程中执行的。（await后面的语句只是正常执行而已）
64、0、undefined、null、NAN、''都是false，[]不是false，数组是引用类型，变量有指向所以不是false
65、Generator的yield表达式没有返回值，next方法的参数就是上一个yield表达式的返回值，在yield表达式需要返回一个值时用到
66、axios发送请求，如果只写路径，协议默认使用地址栏的协议，写完整路径，协议使用URL的协议
67、HTTP协商缓存：


                  