1、async await的使用真意，promise是微任务，settimeout是宏任务
2、es6继承使用super的作用与继承机制
3、JavaScript对象强引用与弱引用
4、防抖、节流代码实现
5、Set、weakSet，Map、weakMap
6、URL和URI的区别
7、Generator （每一段状态是调用next函数时执行的）
8、React的setState什么时候异步什么时候同步（React事务机制）
9、Tcp连接原理及流量控制、拥塞控制
10、npm下载原理（缺省！！！！！！！！）
11、iframe标签
12、判断数组三种方法：Array.isArray()，instanceof(基本类型instanceof Number为false)，object.prototype.toString.call()
13、性能优化（缺省！！！！！！！！！！！）
14、JavaScript事件循环和node事件循环区别
15、观察者模式（要清楚观察者模式的好处及与发布订阅模式的区别）
16、MutaionObserver使用 https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver
17、DOM的nodeType 属性和childNodes 属性
18、二叉树
19、遍历DOM节点demo
20、操作DOM为什么这么慢（js和DOM是分开的，每次操作DOM需要先连接DOM和JavaScript）
21、DOM+BOM+emcascript=JavaScript，DOM是用于操作文档的API，BOM是操作浏览器窗口的API
22、Array flat方法数组扁平化且默认只扁平化一层，传入Infinity参数则转化为一层
23、Array的some方法和forEach方法区别，concat连接数组后返回新的数组，使用扩展运算符手动扁平化数组
24、事件冒泡和观察者模式的关系
25、AST
26、Vue的data为什么是函数（缺省！！！！！！！！！！！！！）
27、a.b.c.d比a['b']['c']['d']快
28、0.1 + 0.2不等于0.3：遵循IEEE754标准的语言都存在的问题，保留两位即可（缺省！！！！！！！！！！！！）
29、JavaScript构造函数可以通过prototype设置原型属性和方法，实例对象不能；实例对象可以通过__proto__访问它的
       原型对象（即构造函数），里面有构造函数和prototype(原型对象的原型对象)
30、React.CreateElement创建DOM元素，创建后不可改变，使用JSX语法最终也会通过CreateElement转化为DOM元素
31、React es6类中的this.num是否作为this.props的属性？（缺省！！！！！！！！！！！！！！）
32、父子组件间props传值
33、React useState和UseEffect
34、服务端渲染：在服务端把对应路由的页面拼接好，再挂载到指定位置(即发给客户端)，客户端渲染(传统的前后端分离)：
        先把静态资源(HTML、css、JavaScript文件)发给前端，再通过脚本获取页面的数据（脚本执行地点不一样）
35、SPA：和传统前后端分离项目类似，初次渲染把所有静态文件发送到客户端，路由切换都在客户端实现(切换页面不需要再
        向服务端请求)
36、Redux回顾：state分散在reducer中，作为一个对象整体，里面的属性是具体状态值；action是整个函数，在reducer
        中的action.type指的是action发送的数据对象；action向整个reducer发送(即通过combineReducers结合的store)
37、SPA路由和SSR路由，子路由的含义(页面局部刷新)，路由的含义，React的BrowserRouter表示路由类型，并不表示路由
        包裹，路由包裹用Routes标签表示
38、object的原型对象（__proto__）是NULL，但是prototype是object构造函数
39、async、await返回promise是执行函数时返回的，需要用变量接着，不是await后面的语句返回的，如果不return，
        await下面的语句就是promise回调的内容，使用return则显示地返回一个promise对象，return的数据就是promise回调的参数
40、即使用return则显式返回promise，需要变量接着，不用return则隐式返回，直接调用函数
41、由上面分析，axios使用await等待后，返回的是响应对象（axios封装好的），不是promise对象！！！！！
42、axios使用await适用单独使用的情况，使用返回promise适用封装axios模块的情况
43、axios接收的响应对象其实是axios封装后的对象，里面的data才是服务端响应的实际对象
44、@reduxjs/toolkit是把reducer和action合二为一了（写法上），但逻辑上是分开的（即分开导出）
45、js-cookie库的使用，封装cookie类
46、react受控组件、非受控组件（类似双向绑定）
47、react处理input输入内容
48、react input设置value属性则用户不能输入内容
49、react props变化不会引起UI刷新，父组件传过来的props值变化会引起UI刷新
50、页面刷新，即父组件重新render，子组件只是进行update生命周期函数，不会卸载重新创建
51、useState作用：保留声明的值，函数重新调用后声明的值不会丢失，在useState调用处返回最新值，并且值更新后刷新UI
52、useEffect作用：第二个参数为空，每次DOM刷新(页面刷新)执行传入的函数，效果类似类组件的didmount和didupdated，
        第二个参数是[]，只初次挂载时执行，类似didmount,第二个参数为其它变量，只变量变化时执行
53、*****react组件重新渲染后，子组件重新渲染的条件是：从父组件接收的props是否改变，改变则重新渲染(不管父组件是否重新渲染)
54、useCallback 设置传入的函数在第二个参数变化后才更改，以优化性能
55、关于react性能优化的几点思考：当有多个子组件接收父组件传来的props时，父组件使用useCallback 或父组件使用类组件，
        把父组件的props作为参数传给子组件，props不变，则子组件也不会重新渲染，但是函数组件渲染后属性也是重新创建的，
         导致子组件重新渲染
56、*********函数组件重新渲染后属性会重置！！！！！相当于重新调用函数（不管是自身重新渲染还是子组件重新渲染）
57、bind是把this指向某个对象然后返回改变this指向后的函数，apply和call是直接改变this指向然后执行（注意三者传参方式）
58、箭头函数的this不能改，且没有super
59、把函数赋给一个变量时，this指向会改变（对象方法赋给变量，会指向当前作用域最高对象），但是还是指向同一个地址，
        即：this是在执行过程中确定的(箭头函数除外)，作用域链是在定义时确定的
60、类数组（具备length属性，通过[]访问元素，但不能调用Array对象的方法，argument对象和DOM获取的节点数组）
61、react事务机制（继续深入）
62、react子组件更新问题：初学者误区：以为父组件render后子组件都要重新渲染。要严格按照组件生命周期函数，组件挂载后，
        重新渲染的条件是：自身state变化和从父组件获取的props变化。render函数的作用更像是把DOM树上有变化的地方做更改
63、typeof str：string，str instanceof String：false。大小写区别
64、prototype只有构造函数有，实例对象没有
65、如果前端没有设置跨域就能跨域，应该是服务端设置了跨域解决方案
66、通过自己的服务端向其它域请求数据，类似正向代理（本质并不一样）
67、浏览器发送请求自动携带cookie（必须是客户端和服务端同域）
68、session
69、token认证方式
70、事件对象，封装事件的参数，事件流（事件捕获、事件冒泡）https://zhuanlan.zhihu.com/p/90644388，https://www.jianshu.com/p/8d8f9aa4b033
        react合成事件，事件机制
71、JavaScript整数相除后不会自动取整，结果是小数
72、vuex中的action异步指的是可以在action中异步请求数据，mutation同步指的是mutation必须同步修改数据
73、箭头函数没有constructor和prototype属性，因此不能使用super且不能改变其this指向，也不能作为构造函数
74、HTTP请求报文和响应报文的头部都是可选的，不设置也行（请求头和响应头）
75、不设置响应头，返回的数据还是数据的原格式
76、HTTP持久化连接？设置cookie其实是web应用本身的事，不是服务端设置前端的cookie，原生web应用和react/vue架都是应用本身设置的
77、HTTP请求头就是一些字段，形式是键值对
78、HTTP报文首部分四种：请求首部、响应首部、通用首部(请求和响应都能用)、实体首部(说明body中内容的信息)
79、冒泡排序、桶排序、快速排序、选择排序，JavaScript清空数组，去掉数组中的重复元素，找出字符串中最多的字符
80、useEffect和useCallBack并不是引起state变化的原因，而是state变化后的响应者
81、数组forEach和some等遍历不改变元素值，from传入的回调会改变传入的数组的元素值
82、洗牌算法
83、react合成事件都可以接收event对象作为参数，定义函数时参数最后一个是event对象
84、react setState异步更新，具体什么时候更新？答案：回调函数进入任务队列中执行后更新，即当前同步代码执行后
85、setState传入对象更新会被覆盖，传入函数不会被覆盖
86、关于异步操作什么时候执行，答案是在同步代码或任务队列执行完之后
87、react生命周期回顾，constructor在componentWillMount之前执行（不实例化组件怎么执行函数）
88、受控组件和非受控组件就是看你怎么处理他的值，如果是根据原生DOM的形式获取值，比如input使用ref获取值，就是
        非受控组件，如果使用输入事件并通过react封装的event事件获取输入的值，它就是受控组件。受控就是产生的值受当前组件
        的state控制
89、react context使用
90、react异步加载组件，多个子组件 不需要同时加载，优化加载效果
91、react路由的switch和exact。react路由会显示匹配到的路由，URL为/home时/和/home都会展示，使用switch会展示
        第一个找到的路由，后面的不展示，但是不是精准匹配，比如URL是/home，但是没有home路由，此时会匹配到/或者/:id等，
         exact设置精准匹配，只有URL完全一致才能显示
92、vue路由hash模式和history模式区别
93、react PureComponent浅比较state，减少页面刷新
94、react高阶组件，redux的connect方法就是高阶组件
95、react render props就是把类和函数的父子组件关系换了一下，函数组件负责展示内容，类组件负责提供数据，可以
        减少子组件重新render
96、SPA可理解为胖客户端
97、webSocket（继续学习）
98、进程和线程（继续学习）
99、CORS跨域
100、数组的索引只能是数字！！！！！使用['a']设置的是属性，因为数组也是对象，可以这样设置属性
101、JavaScript对象的索引只能是字符串！！！！！！这就是和map的不同。数组去重最好使用数组做容器
102、使用桶的思想的算法，一定要考虑好元素是数字类型还是字符串类型，数字类型就用数组做桶，字符串就用对象做桶，
          也可直接使用map做桶，map的键可以是任意类型，保留了元素的类型，不需要考虑元素类型
103、异步、回调其实是主线程执行同步创建的部分，其他线程(计时器线程、Ajax线程等)执行具体操作部分(不是主线程执行的)，其他线程执行完后，
          任务队列线程（浏览器渲染进程中的线程）把回调函数加入到任务队列中
104、在代码执行前有一个预编译阶段，把变量生命作为变量对象的属性，代码执行时进行赋值等操作
105、JavaScript立即执行函数什么时候执行？定义后执行还是执行时执行？
106、react setState异步同步问题和传入对象与传入函数的区别结合
107、JavaScript对象的索引是字符串，设置时传入的不是字符串会转化为字符串，数组索引是数字，使用['a']是设置属性，数组的
      length属性值不会改变，使用[0]是设置数组元素，length属性会改变
108、redux的state不用单独设置一个对象，单独设置对象无非就是模块化管理了，vuex在这一点和redux还是有点区别的
109、es6函数的扩展：（1）默认参数最好放在最后一个位置（2）使用默认参数的函数初始化时会形成一个
	局部作用域(不是函数体内部的作用域)（3）rest参数：使用...value把传入的多个参数合成一个数组，数组名为value
        （4）函数name属性返回函数名（5）函数尾调用：return一个函数调用，会把外层函数的调用帧删掉(在尾部函数不需要
           外层函数中的变量的情况下)，节省内存





